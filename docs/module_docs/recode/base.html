<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>recode.base &mdash; recode 0.1.24 documentation</title><link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/copybutton.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/graphviz.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  <script id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/doctools.js"></script>
        <script src="../../_static/language_data.js"></script>
        <script src="../../_static/toggleprompt.js"></script>
        <script src="../../_static/clipboard.min.js"></script>
        <script src="../../_static/copybutton.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="recode.util" href="util.html" />
    <link rel="prev" title="recode.audio" href="audio.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../../index.html" class="icon icon-home"> recode
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../recode.html">recode</a></li>
<li class="toctree-l1"><a class="reference internal" href="audio.html">recode.audio</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">recode.base</a></li>
<li class="toctree-l1"><a class="reference internal" href="util.html">recode.util</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">recode</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home"></a> &raquo;</li>
      <li>recode.base</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../../_sources/module_docs/recode/base.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="module-recode.base">
<span id="recode-base"></span><h1>recode.base<a class="headerlink" href="#module-recode.base" title="Permalink to this headline">¶</a></h1>
<p>Base recode objects</p>
<dl class="py class">
<dt id="recode.base.ChunkedDecoder">
<em class="property">class </em><code class="sig-prename descclassname">recode.base.</code><code class="sig-name descname">ChunkedDecoder</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">chk_to_frame</span><span class="p">:</span> <span class="n">Callable<span class="p">[</span><span class="p">[</span>Sequence<span class="p">[</span>bytes<span class="p">]</span><span class="p">]</span><span class="p">, </span>Union<span class="p">[</span>Any<span class="p">, </span>Sequence<span class="p">[</span>Any<span class="p">]</span><span class="p">]</span><span class="p">]</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/recode/base.html#ChunkedDecoder"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#recode.base.ChunkedDecoder" title="Permalink to this definition">¶</a></dt>
<dd><p>Deserializes numerical streams and sequences serialized by ChunkedEncoder</p>
</dd></dl>

<dl class="py class">
<dt id="recode.base.ChunkedEncoder">
<em class="property">class </em><code class="sig-prename descclassname">recode.base.</code><code class="sig-name descname">ChunkedEncoder</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">frame_to_chk</span><span class="p">:</span> <span class="n">Callable<span class="p">[</span><span class="p">[</span>Union<span class="p">[</span>Any<span class="p">, </span>Sequence<span class="p">[</span>Any<span class="p">]</span><span class="p">]</span><span class="p">]</span><span class="p">, </span>Sequence<span class="p">[</span>bytes<span class="p">]</span><span class="p">]</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/recode/base.html#ChunkedEncoder"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#recode.base.ChunkedEncoder" title="Permalink to this definition">¶</a></dt>
<dd><p>Serializes numerical streams and sequences</p>
</dd></dl>

<dl class="py class">
<dt id="recode.base.IterativeDecoder">
<em class="property">class </em><code class="sig-prename descclassname">recode.base.</code><code class="sig-name descname">IterativeDecoder</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">chk_to_frame</span><span class="p">:</span> <span class="n">Callable<span class="p">[</span><span class="p">[</span>Sequence<span class="p">[</span>bytes<span class="p">]</span><span class="p">]</span><span class="p">, </span>Union<span class="p">[</span>Any<span class="p">, </span>Sequence<span class="p">[</span>Any<span class="p">]</span><span class="p">]</span><span class="p">]</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/recode/base.html#IterativeDecoder"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#recode.base.IterativeDecoder" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates an iterator of deserialized chunks of numerical streams and sequences serialized
by ChunkedEncoder</p>
</dd></dl>

<dl class="py class">
<dt id="recode.base.MetaDecoder">
<em class="property">class </em><code class="sig-prename descclassname">recode.base.</code><code class="sig-name descname">MetaDecoder</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">chk_to_frame</span><span class="p">:</span> <span class="n">Callable<span class="p">[</span><span class="p">[</span>Sequence<span class="p">[</span>bytes<span class="p">]</span><span class="p">]</span><span class="p">, </span>Union<span class="p">[</span>Any<span class="p">, </span>Sequence<span class="p">[</span>Any<span class="p">]</span><span class="p">]</span><span class="p">]</span></span></em>, <em class="sig-param"><span class="n">meta_to_frame</span><span class="p">:</span> <span class="n">Callable<span class="p">[</span><span class="p">[</span>Sequence<span class="p">[</span>bytes<span class="p">]</span><span class="p">]</span><span class="p">, </span>Union<span class="p">[</span>Any<span class="p">, </span>Sequence<span class="p">[</span>Any<span class="p">]</span><span class="p">]</span><span class="p">]</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/recode/base.html#MetaDecoder"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#recode.base.MetaDecoder" title="Permalink to this definition">¶</a></dt>
<dd><p>Deserializes tabular data serialized by MetaEncoder</p>
</dd></dl>

<dl class="py class">
<dt id="recode.base.MetaEncoder">
<em class="property">class </em><code class="sig-prename descclassname">recode.base.</code><code class="sig-name descname">MetaEncoder</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">frame_to_chk</span><span class="p">:</span> <span class="n">Callable<span class="p">[</span><span class="p">[</span>Union<span class="p">[</span>Any<span class="p">, </span>Sequence<span class="p">[</span>Any<span class="p">]</span><span class="p">]</span><span class="p">]</span><span class="p">, </span>Sequence<span class="p">[</span>bytes<span class="p">]</span><span class="p">]</span></span></em>, <em class="sig-param"><span class="n">frame_to_meta</span><span class="p">:</span> <span class="n">Callable<span class="p">[</span><span class="p">[</span>Union<span class="p">[</span>Any<span class="p">, </span>Sequence<span class="p">[</span>Any<span class="p">]</span><span class="p">]</span><span class="p">]</span><span class="p">, </span>Sequence<span class="p">[</span>bytes<span class="p">]</span><span class="p">]</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/recode/base.html#MetaEncoder"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#recode.base.MetaEncoder" title="Permalink to this definition">¶</a></dt>
<dd><p>Serializes tabular data (must be formatted as list of dicts)</p>
</dd></dl>

<dl class="py class">
<dt id="recode.base.StructCodecSpecs">
<em class="property">class </em><code class="sig-prename descclassname">recode.base.</code><code class="sig-name descname">StructCodecSpecs</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">chk_format</span><span class="p">:</span> <span class="n">str</span> <span class="o">=</span> <span class="default_value">'d'</span></em>, <em class="sig-param"><span class="n">n_channels</span><span class="p">:</span> <span class="n">int</span> <span class="o">=</span> <span class="default_value">None</span></em>, <em class="sig-param"><span class="n">chk_size_bytes</span><span class="p">:</span> <span class="n">int</span> <span class="o">=</span> <span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/recode/base.html#StructCodecSpecs"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#recode.base.StructCodecSpecs" title="Permalink to this definition">¶</a></dt>
<dd><p>Enable the definition of codec specs based on format characters of the
python struct module
(<a class="reference external" href="https://docs.python.org/3/library/struct.html#format-characters">https://docs.python.org/3/library/struct.html#format-characters</a>)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>chk_format</strong> – The format of a chunk, as specified by the struct module
The length of the string specifies the number of “channels”,
and each individual character of the string specifies the kind of encoding
you should apply to each “channel” (hold your horses, we’ll explain).
See <a class="reference external" href="https://docs.python.org/3/library/struct.html#format-characters">https://docs.python.org/3/library/struct.html#format-characters</a></p></li>
<li><p><strong>n_channels</strong> – Expected of channels. If given, will assert that the
number of channels expressed by the <cite>chk_format</cite> is indeed what is expected.
the number of channels expressed by the <cite>chk_format</cite>.</p></li>
<li><p><strong>chk_size_bytes</strong> – Expected number of bytes per chunk.
If given, will assert that the chunk size expressed by the <cite>chk_format</cite> is
indeed the one expected.</p></li>
</ul>
</dd>
</dl>
<p>Note: All encoder/decoder (codec) specs can be expressed though the <cite>chk_format</cite>.
Yet, though <cite>n_channels</cite> and <cite>chk_size_bytes</cite> are both optional, it is advised to
include them in production code since they act as extra confirmation of the codec
to be used. Encoding and decoding problems can be hard to notice until much
later on downstream, and are therefore hard to debug.</p>
<p>To utilise recode, first define your codec specs. If your frame is only one channel
(ex. a list) then your format string will include two characters,
a byte character (&#64;, =, &lt;, &gt;, !) and a format character. The format character
should match the data type of the samples in the frame so they are properly
encoded/decoded. This can be seen in thefollowing example.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">specs</span> <span class="o">=</span> <span class="n">StructCodecSpecs</span><span class="p">(</span><span class="n">chk_format</span><span class="o">=</span><span class="s1">&#39;h&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">specs</span><span class="p">)</span>
<span class="go">StructCodecSpecs(chk_format=&#39;h&#39;, n_channels=1, chk_size_bytes=2)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">encoder</span> <span class="o">=</span> <span class="n">ChunkedEncoder</span><span class="p">(</span><span class="n">frame_to_chk</span><span class="o">=</span><span class="n">specs</span><span class="o">.</span><span class="n">frame_to_chk</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">decoder</span> <span class="o">=</span> <span class="n">ChunkedDecoder</span><span class="p">(</span><span class="n">chk_to_frame</span><span class="o">=</span><span class="n">specs</span><span class="o">.</span><span class="n">chk_to_frame</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">frames</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">encoder</span><span class="p">(</span><span class="n">frames</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">b</span> <span class="o">==</span> <span class="sa">b</span><span class="s1">&#39;</span><span class="se">\x01\x00\x02\x00\x03\x00</span><span class="s1">&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">decoded_frames</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">decoder</span><span class="p">(</span><span class="n">b</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">decoded_frames</span> <span class="o">==</span> <span class="n">frames</span>
</pre></div>
</div>
<p>The only reason (but it’s a good one) to specify <cite>n_channels</cite> is to assert them.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">specs</span> <span class="o">=</span> <span class="n">StructCodecSpecs</span><span class="p">(</span><span class="n">chk_format</span><span class="o">=</span><span class="s1">&#39;@hh&#39;</span><span class="p">,</span> <span class="n">n_channels</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">specs</span><span class="p">)</span>
<span class="go">StructCodecSpecs(chk_format=&#39;@hh&#39;, n_channels=2, chk_size_bytes=4)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">encoder</span> <span class="o">=</span> <span class="n">ChunkedEncoder</span><span class="p">(</span><span class="n">frame_to_chk</span><span class="o">=</span><span class="n">specs</span><span class="o">.</span><span class="n">frame_to_chk</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">decoder</span> <span class="o">=</span> <span class="n">ChunkedDecoder</span><span class="p">(</span><span class="n">chk_to_frame</span><span class="o">=</span><span class="n">specs</span><span class="o">.</span><span class="n">chk_to_frame</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">frames</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">encoder</span><span class="p">(</span><span class="n">frames</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">b</span> <span class="o">==</span> <span class="sa">b</span><span class="s1">&#39;</span><span class="se">\x01\x00\x02\x00\x03\x00\x04\x00\x05\x00\x06\x00</span><span class="s1">&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">decoded_frames</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">decoder</span><span class="p">(</span><span class="n">b</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">decoded_frames</span> <span class="o">==</span> <span class="n">frames</span>
</pre></div>
</div>
<p>On the other hand, if each channel has a different data type, say (int, float, int),
then your format string needs a format character for each of your channels.
This can be seen in the following example, which also shows the use
of a different byte character (=).</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">specs</span> <span class="o">=</span> <span class="n">StructCodecSpecs</span><span class="p">(</span><span class="n">chk_format</span> <span class="o">=</span> <span class="s1">&#39;=hdh&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">specs</span><span class="p">)</span>
<span class="go">StructCodecSpecs(chk_format=&#39;=hdh&#39;, n_channels=3, chk_size_bytes=12)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">encoder</span> <span class="o">=</span> <span class="n">ChunkedEncoder</span><span class="p">(</span><span class="n">frame_to_chk</span> <span class="o">=</span> <span class="n">specs</span><span class="o">.</span><span class="n">frame_to_chk</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">decoder</span> <span class="o">=</span> <span class="n">ChunkedDecoder</span><span class="p">(</span><span class="n">chk_to_frame</span><span class="o">=</span><span class="n">specs</span><span class="o">.</span><span class="n">chk_to_frame</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">frames</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">1</span><span class="p">,</span> <span class="mf">2.45</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mf">4.321</span><span class="p">,</span> <span class="mi">3</span><span class="p">)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">encoder</span><span class="p">(</span><span class="n">frames</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">b</span> <span class="o">==</span> <span class="sa">b</span><span class="s1">&#39;</span><span class="se">\x01\x00\x9a\x99\x99\x99\x99\x99\x03</span><span class="s1">@</span><span class="se">\x01\x00\x03\x00</span><span class="s1">b</span><span class="se">\x10</span><span class="s1">X9</span><span class="se">\xb4</span><span class="s1">H</span><span class="se">\x11</span><span class="s1">@</span><span class="se">\x03\x00</span><span class="s1">&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">decoded_frames</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">decoder</span><span class="p">(</span><span class="n">b</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">decoded_frames</span> <span class="o">==</span> <span class="n">frames</span>
</pre></div>
</div>
<p>Along with a ChunkedDecoder, you can also use an IterativeDecoder which implements
the struct.iter_unpack function.
IterativeDecoder only requires one argument, a chk_to_frame_iter function,
and returns an iterator of each chunk.
An example of an IterativeDecorator can be seen below.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">specs</span> <span class="o">=</span> <span class="n">StructCodecSpecs</span><span class="p">(</span><span class="n">chk_format</span> <span class="o">=</span> <span class="s1">&#39;hdhd&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">specs</span><span class="p">)</span>
<span class="go">StructCodecSpecs(chk_format=&#39;hdhd&#39;, n_channels=4, chk_size_bytes=32)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">encoder</span> <span class="o">=</span> <span class="n">ChunkedEncoder</span><span class="p">(</span><span class="n">frame_to_chk</span> <span class="o">=</span> <span class="n">specs</span><span class="o">.</span><span class="n">frame_to_chk</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">decoder</span> <span class="o">=</span> <span class="n">IterativeDecoder</span><span class="p">(</span><span class="n">chk_to_frame</span> <span class="o">=</span> <span class="n">specs</span><span class="o">.</span><span class="n">chk_to_frame</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">frames</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">1</span><span class="p">,</span><span class="mf">1.1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mf">1.1</span><span class="p">),(</span><span class="mi">2</span><span class="p">,</span><span class="mf">2.2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mf">2.2</span><span class="p">),(</span><span class="mi">3</span><span class="p">,</span><span class="mf">3.3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mf">3.3</span><span class="p">)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">encoder</span><span class="p">(</span><span class="n">frames</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">iter_frames</span> <span class="o">=</span> <span class="n">decoder</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="nb">next</span><span class="p">(</span><span class="n">iter_frames</span><span class="p">)</span> <span class="o">==</span> <span class="n">frames</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">next</span><span class="p">(</span><span class="n">iter_frames</span><span class="p">)</span>
<span class="go">(2, 2.2, 2, 2.2)</span>
</pre></div>
</div>
<p>Along with using recode for the kinds of data we have looked at so far,
it can also be applied to DataFrames when
they have been converted to a list of dicts using MetaEncoder and MetaDecoder.
An example of this can be seen below.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="p">[{</span><span class="s1">&#39;foo&#39;</span><span class="p">:</span> <span class="mf">1.1</span><span class="p">,</span> <span class="s1">&#39;bar&#39;</span><span class="p">:</span> <span class="mf">2.2</span><span class="p">},</span>
<span class="gp">... </span>        <span class="p">{</span><span class="s1">&#39;foo&#39;</span><span class="p">:</span> <span class="mf">513.23</span><span class="p">,</span> <span class="s1">&#39;bar&#39;</span><span class="p">:</span> <span class="mf">456.1</span><span class="p">},</span>
<span class="gp">... </span>        <span class="p">{</span><span class="s1">&#39;foo&#39;</span><span class="p">:</span> <span class="mf">32.0</span><span class="p">,</span> <span class="s1">&#39;bar&#39;</span><span class="p">:</span> <span class="mf">6.7</span><span class="p">}]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">specs</span> <span class="o">=</span> <span class="n">StructCodecSpecs</span><span class="p">(</span><span class="n">chk_format</span><span class="o">=</span><span class="s1">&#39;dd&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">specs</span><span class="p">)</span>
<span class="go">StructCodecSpecs(chk_format=&#39;dd&#39;, n_channels=2, chk_size_bytes=16)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">encoder</span> <span class="o">=</span> <span class="n">MetaEncoder</span><span class="p">(</span><span class="n">frame_to_chk</span> <span class="o">=</span> <span class="n">specs</span><span class="o">.</span><span class="n">frame_to_chk</span><span class="p">,</span> <span class="n">frame_to_meta</span> <span class="o">=</span> <span class="n">frame_to_meta</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">decoder</span> <span class="o">=</span> <span class="n">MetaDecoder</span><span class="p">(</span><span class="n">chk_to_frame</span> <span class="o">=</span> <span class="n">specs</span><span class="o">.</span><span class="n">chk_to_frame</span><span class="p">,</span> <span class="n">meta_to_frame</span> <span class="o">=</span> <span class="n">meta_to_frame</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">encoder</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">decoder</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="o">==</span> <span class="n">data</span>
</pre></div>
</div>
</dd></dl>

<dl class="py class">
<dt id="recode.base.codec_tuple">
<em class="property">class </em><code class="sig-prename descclassname">recode.base.</code><code class="sig-name descname">codec_tuple</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">encode</span></em>, <em class="sig-param"><span class="n">decode</span></em><span class="sig-paren">)</span><a class="headerlink" href="#recode.base.codec_tuple" title="Permalink to this definition">¶</a></dt>
<dd><dl class="py attribute">
<dt id="recode.base.codec_tuple.decode">
<code class="sig-name descname">decode</code><a class="headerlink" href="#recode.base.codec_tuple.decode" title="Permalink to this definition">¶</a></dt>
<dd><p>Alias for field number 1</p>
</dd></dl>

<dl class="py attribute">
<dt id="recode.base.codec_tuple.encode">
<code class="sig-name descname">encode</code><a class="headerlink" href="#recode.base.codec_tuple.encode" title="Permalink to this definition">¶</a></dt>
<dd><p>Alias for field number 0</p>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt id="recode.base.frame_to_meta">
<code class="sig-prename descclassname">recode.base.</code><code class="sig-name descname">frame_to_meta</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">frame</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/recode/base.html#frame_to_meta"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#recode.base.frame_to_meta" title="Permalink to this definition">¶</a></dt>
<dd><p>Defines header for serialization of tabluar data
&gt;&gt;&gt; rows = [{‘customer’: 1}, {‘customer’: 2}, {‘customer’: 3}]
&gt;&gt;&gt; assert frame_to_meta(rows) == b’x08x00customer’</p>
</dd></dl>

<dl class="py function">
<dt id="recode.base.meta_to_frame">
<code class="sig-prename descclassname">recode.base.</code><code class="sig-name descname">meta_to_frame</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">meta</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/recode/base.html#meta_to_frame"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#recode.base.meta_to_frame" title="Permalink to this definition">¶</a></dt>
<dd><p>Deserializes header for deserialization of tabular data
&gt;&gt;&gt; meta = b’x1cx00customer.apple.banana.tomatox01x00x01x00x02x00x03x00x02x00… x03x00x02x00x05x00x01x00x03x00x04x00tx00’
&gt;&gt;&gt; assert meta_to_frame(meta)[0] == [‘customer’, ‘apple’, ‘banana’, ‘tomato’]</p>
</dd></dl>

<dl class="py function">
<dt id="recode.base.mk_codec">
<code class="sig-prename descclassname">recode.base.</code><code class="sig-name descname">mk_codec</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">chk_format</span><span class="p">:</span> <span class="n">str</span> <span class="o">=</span> <span class="default_value">'d'</span></em>, <em class="sig-param"><span class="n">n_channels</span><span class="p">:</span> <span class="n">int</span> <span class="o">=</span> <span class="default_value">None</span></em>, <em class="sig-param"><span class="n">chk_size_bytes</span><span class="p">:</span> <span class="n">int</span> <span class="o">=</span> <span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/recode/base.html#mk_codec"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#recode.base.mk_codec" title="Permalink to this definition">¶</a></dt>
<dd><p>Enable the definition of codec specs based on <cite>chk_format</cite>,
format characters of the python struct module
(<a class="reference external" href="https://docs.python.org/3/library/struct.html#format-characters">https://docs.python.org/3/library/struct.html#format-characters</a>)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>chk_format</strong> – The format of a chunk, as specified by the struct module
The length of the string specifies the number of “channels”,
and each individual character of the string specifies the kind of encoding
you should apply to each “channel” (hold your horses, we’ll explain).
See <a class="reference external" href="https://docs.python.org/3/library/struct.html#format-characters">https://docs.python.org/3/library/struct.html#format-characters</a></p></li>
<li><p><strong>n_channels</strong> – Expected of channels. If given, will assert that the
number of channels expressed by the <cite>chk_format</cite> is indeed what is expected.
the number of channels expressed by the <cite>chk_format</cite>.</p></li>
<li><p><strong>chk_size_bytes</strong> – Expected number of bytes per chunk.
If given, will assert that the chunk size expressed by the <cite>chk_format</cite> is
indeed the one expected.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A (named)tuple with encode and decode functions</p>
</dd>
</dl>
<p>The easiest and bigest bang for your buck is <code class="docutils literal notranslate"><span class="pre">mk_codec</span></code></p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">recode</span> <span class="kn">import</span> <span class="n">mk_codec</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">encoder</span><span class="p">,</span> <span class="n">decoder</span> <span class="o">=</span> <span class="n">mk_codec</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">encoder</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="mf">3.14</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span>
<span class="go">b&#39;\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x08\xc0\x1f\x85\xebQ\xb8\x1e\t@&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">decoder</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="go">[0.0, -3.0, 3.14]</span>
</pre></div>
</div>
<p>What about those channels?
Well, some times you need to encode/decode multi-channel streams, such as:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">multi_channel_stream</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">3</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="o">-</span><span class="mi">9</span><span class="p">]]</span>
</pre></div>
</div>
<p>Say, for example, if you were dealing with stereo waveform
(with the standard PCM_16 format), you’d do it this way:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">encoder</span><span class="p">,</span> <span class="n">decoder</span> <span class="o">=</span> <span class="n">mk_codec</span><span class="p">(</span><span class="s1">&#39;hh&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pcm_bytes</span> <span class="o">=</span> <span class="n">encoder</span><span class="p">(</span><span class="nb">iter</span><span class="p">(</span><span class="n">multi_channel_stream</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pcm_bytes</span>
<span class="go">b&#39;\x03\x00\xff\xff\x04\x00\xff\xff\x05\x00\xf7\xff&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">decoder</span><span class="p">(</span><span class="n">pcm_bytes</span><span class="p">)</span>
<span class="go">[(3, -1), (4, -1), (5, -9)]</span>
</pre></div>
</div>
<p>The <cite>n_channels</cite> and <cite>chk_size_bytes</cite> arguments are there if you want to assert
that your number of channels and chunk size are what you expect.
Again, these are just for verification, because we know how easy it is to
misspecify the <cite>chk_format</cite>, and how hard it can be to notice that we did.</p>
<p>It is advised to use these in any production code, for the sanity of everyone!</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mk_codec</span><span class="p">(</span><span class="s1">&#39;hhh&#39;</span><span class="p">,</span> <span class="n">n_channels</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
  <span class="c">...</span>
<span class="gr">AssertionError</span>: <span class="n">You said there&#39;d be 2 channels, but I inferred 3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mk_codec</span><span class="p">(</span><span class="s1">&#39;hhh&#39;</span><span class="p">,</span> <span class="n">chk_size_bytes</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
  <span class="c">...</span>
<span class="gr">AssertionError</span>: <span class="n">The given chk_size_bytes 3 did not match the inferred (from chk_format) 6</span>
</pre></div>
</div>
<p>Finally, so far we’ve done it this way:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">encoder</span><span class="p">,</span> <span class="n">decoder</span> <span class="o">=</span> <span class="n">mk_codec</span><span class="p">(</span><span class="s1">&#39;hHifd&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>But see that what’s actually returned is a NAMED tuple, which means that you can
can also get one object that will have <cite>.encode</cite> and <cite>.decode</cite> properties:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">codec</span> <span class="o">=</span> <span class="n">mk_codec</span><span class="p">(</span><span class="s1">&#39;hHifd&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">to_encode</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="p">[</span><span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">10</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">encoded</span> <span class="o">=</span> <span class="n">codec</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="n">to_encode</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">decoded</span> <span class="o">=</span> <span class="n">codec</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="n">encoded</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">decoded</span>
<span class="go">[(1, 2, 3, 4.0, 5.0), (6, 7, 8, 9.0, 10.0)]</span>
</pre></div>
</div>
<p>And you can checkout the properties of your encoder and decoder (they
should be the same)</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">codec</span><span class="o">.</span><span class="n">encode</span><span class="o">.</span><span class="n">chk_format</span>
<span class="go">&#39;hHifd&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">codec</span><span class="o">.</span><span class="n">encode</span><span class="o">.</span><span class="n">n_channels</span>
<span class="go">5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">codec</span><span class="o">.</span><span class="n">encode</span><span class="o">.</span><span class="n">chk_size_bytes</span>
<span class="go">24</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="recode.base.mk_encoder_and_decoder">
<code class="sig-prename descclassname">recode.base.</code><code class="sig-name descname">mk_encoder_and_decoder</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">chk_format</span><span class="p">:</span> <span class="n">str</span> <span class="o">=</span> <span class="default_value">'d'</span></em>, <em class="sig-param"><span class="n">n_channels</span><span class="p">:</span> <span class="n">int</span> <span class="o">=</span> <span class="default_value">None</span></em>, <em class="sig-param"><span class="n">chk_size_bytes</span><span class="p">:</span> <span class="n">int</span> <span class="o">=</span> <span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#recode.base.mk_encoder_and_decoder" title="Permalink to this definition">¶</a></dt>
<dd><p>Enable the definition of codec specs based on <cite>chk_format</cite>,
format characters of the python struct module
(<a class="reference external" href="https://docs.python.org/3/library/struct.html#format-characters">https://docs.python.org/3/library/struct.html#format-characters</a>)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>chk_format</strong> – The format of a chunk, as specified by the struct module
The length of the string specifies the number of “channels”,
and each individual character of the string specifies the kind of encoding
you should apply to each “channel” (hold your horses, we’ll explain).
See <a class="reference external" href="https://docs.python.org/3/library/struct.html#format-characters">https://docs.python.org/3/library/struct.html#format-characters</a></p></li>
<li><p><strong>n_channels</strong> – Expected of channels. If given, will assert that the
number of channels expressed by the <cite>chk_format</cite> is indeed what is expected.
the number of channels expressed by the <cite>chk_format</cite>.</p></li>
<li><p><strong>chk_size_bytes</strong> – Expected number of bytes per chunk.
If given, will assert that the chunk size expressed by the <cite>chk_format</cite> is
indeed the one expected.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A (named)tuple with encode and decode functions</p>
</dd>
</dl>
<p>The easiest and bigest bang for your buck is <code class="docutils literal notranslate"><span class="pre">mk_codec</span></code></p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">recode</span> <span class="kn">import</span> <span class="n">mk_codec</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">encoder</span><span class="p">,</span> <span class="n">decoder</span> <span class="o">=</span> <span class="n">mk_codec</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">encoder</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="mf">3.14</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span>
<span class="go">b&#39;\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x08\xc0\x1f\x85\xebQ\xb8\x1e\t@&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">decoder</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="go">[0.0, -3.0, 3.14]</span>
</pre></div>
</div>
<p>What about those channels?
Well, some times you need to encode/decode multi-channel streams, such as:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">multi_channel_stream</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">3</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="o">-</span><span class="mi">9</span><span class="p">]]</span>
</pre></div>
</div>
<p>Say, for example, if you were dealing with stereo waveform
(with the standard PCM_16 format), you’d do it this way:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">encoder</span><span class="p">,</span> <span class="n">decoder</span> <span class="o">=</span> <span class="n">mk_codec</span><span class="p">(</span><span class="s1">&#39;hh&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pcm_bytes</span> <span class="o">=</span> <span class="n">encoder</span><span class="p">(</span><span class="nb">iter</span><span class="p">(</span><span class="n">multi_channel_stream</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pcm_bytes</span>
<span class="go">b&#39;\x03\x00\xff\xff\x04\x00\xff\xff\x05\x00\xf7\xff&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">decoder</span><span class="p">(</span><span class="n">pcm_bytes</span><span class="p">)</span>
<span class="go">[(3, -1), (4, -1), (5, -9)]</span>
</pre></div>
</div>
<p>The <cite>n_channels</cite> and <cite>chk_size_bytes</cite> arguments are there if you want to assert
that your number of channels and chunk size are what you expect.
Again, these are just for verification, because we know how easy it is to
misspecify the <cite>chk_format</cite>, and how hard it can be to notice that we did.</p>
<p>It is advised to use these in any production code, for the sanity of everyone!</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mk_codec</span><span class="p">(</span><span class="s1">&#39;hhh&#39;</span><span class="p">,</span> <span class="n">n_channels</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
  <span class="c">...</span>
<span class="gr">AssertionError</span>: <span class="n">You said there&#39;d be 2 channels, but I inferred 3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mk_codec</span><span class="p">(</span><span class="s1">&#39;hhh&#39;</span><span class="p">,</span> <span class="n">chk_size_bytes</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
  <span class="c">...</span>
<span class="gr">AssertionError</span>: <span class="n">The given chk_size_bytes 3 did not match the inferred (from chk_format) 6</span>
</pre></div>
</div>
<p>Finally, so far we’ve done it this way:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">encoder</span><span class="p">,</span> <span class="n">decoder</span> <span class="o">=</span> <span class="n">mk_codec</span><span class="p">(</span><span class="s1">&#39;hHifd&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>But see that what’s actually returned is a NAMED tuple, which means that you can
can also get one object that will have <cite>.encode</cite> and <cite>.decode</cite> properties:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">codec</span> <span class="o">=</span> <span class="n">mk_codec</span><span class="p">(</span><span class="s1">&#39;hHifd&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">to_encode</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="p">[</span><span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">10</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">encoded</span> <span class="o">=</span> <span class="n">codec</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="n">to_encode</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">decoded</span> <span class="o">=</span> <span class="n">codec</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="n">encoded</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">decoded</span>
<span class="go">[(1, 2, 3, 4.0, 5.0), (6, 7, 8, 9.0, 10.0)]</span>
</pre></div>
</div>
<p>And you can checkout the properties of your encoder and decoder (they
should be the same)</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">codec</span><span class="o">.</span><span class="n">encode</span><span class="o">.</span><span class="n">chk_format</span>
<span class="go">&#39;hHifd&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">codec</span><span class="o">.</span><span class="n">encode</span><span class="o">.</span><span class="n">n_channels</span>
<span class="go">5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">codec</span><span class="o">.</span><span class="n">encode</span><span class="o">.</span><span class="n">chk_size_bytes</span>
<span class="go">24</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="recode.base.specs_from_frames">
<code class="sig-prename descclassname">recode.base.</code><code class="sig-name descname">specs_from_frames</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">frames</span><span class="p">:</span> <span class="n">Iterable<span class="p">[</span>Union<span class="p">[</span>Any<span class="p">, </span>Sequence<span class="p">[</span>Any<span class="p">]</span><span class="p">]</span><span class="p">]</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/recode/base.html#specs_from_frames"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#recode.base.specs_from_frames" title="Permalink to this definition">¶</a></dt>
<dd><p>Implicitly defines the codec specs based on the frames to encode/decode.
specs_from_frames returns a tuple of an iterator of frames and the defined StructCodecSpecs. If frames is an
iterable, then the iterator can be ignored like the following example.
&gt;&gt;&gt; frames = [1,2,3]
&gt;&gt;&gt; _, specs = specs_from_frames(frames)
&gt;&gt;&gt; print(specs)
StructCodecSpecs(chk_format=’h’, n_channels=1, chk_size_bytes=2)
&gt;&gt;&gt; encoder = ChunkedEncoder(frame_to_chk = specs.frame_to_chk)
&gt;&gt;&gt; decoder = ChunkedDecoder(chk_to_frame=specs.chk_to_frame)
&gt;&gt;&gt; b = encoder(frames)
&gt;&gt;&gt; assert b == b’x01x00x02x00x03x00’
&gt;&gt;&gt; decoded_frames = list(decoder(b))
&gt;&gt;&gt; assert decoded_frames == frames</p>
<p>If frames is an iterator, then we can still use specs_from_frames as long as we redefine frames from the output like
in the following example.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">frames</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">([[</span><span class="mf">1.1</span><span class="p">,</span><span class="mf">2.2</span><span class="p">],[</span><span class="mf">3.3</span><span class="p">,</span><span class="mf">4.4</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">frames</span><span class="p">,</span> <span class="n">specs</span> <span class="o">=</span> <span class="n">specs_from_frames</span><span class="p">(</span><span class="n">frames</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">specs</span><span class="p">)</span>
<span class="go">StructCodecSpecs(chk_format=&#39;dd&#39;, n_channels=2, chk_size_bytes=16)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">encoder</span> <span class="o">=</span> <span class="n">ChunkedEncoder</span><span class="p">(</span><span class="n">frame_to_chk</span> <span class="o">=</span> <span class="n">specs</span><span class="o">.</span><span class="n">frame_to_chk</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">decoder</span> <span class="o">=</span> <span class="n">ChunkedDecoder</span><span class="p">(</span><span class="n">chk_to_frame</span><span class="o">=</span><span class="n">specs</span><span class="o">.</span><span class="n">chk_to_frame</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">encoder</span><span class="p">(</span><span class="n">frames</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">decoded_frames</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">decoder</span><span class="p">(</span><span class="n">b</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">decoded_frames</span> <span class="o">==</span> <span class="p">[(</span><span class="mf">1.1</span><span class="p">,</span><span class="mf">2.2</span><span class="p">),(</span><span class="mf">3.3</span><span class="p">,</span><span class="mf">4.4</span><span class="p">)]</span>
</pre></div>
</div>
</dd></dl>

</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="audio.html" class="btn btn-neutral float-left" title="recode.audio" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="util.html" class="btn btn-neutral float-right" title="recode.util" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright NO COPYRIGHT.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>