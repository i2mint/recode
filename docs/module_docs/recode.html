
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>recode &#8212; recode 0.1.5 documentation</title>
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../_static/graphviz.css" />
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="recode.util" href="recode/util.html" />
    <link rel="prev" title="Welcome to recode’s documentation!" href="../index.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="module-recode">
<span id="recode"></span><h1>recode<a class="headerlink" href="#module-recode" title="Permalink to this headline">¶</a></h1>
<p>Make codecs for fixed size structured chunks serialization and deserialization of
sequences, tabular data, and time-series.</p>
<dl class="py class">
<dt id="recode.ChunkedDecoder">
<em class="property">class </em><code class="sig-prename descclassname">recode.</code><code class="sig-name descname">ChunkedDecoder</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">*</span><span class="n">args</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwds</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/recode.html#ChunkedDecoder"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#recode.ChunkedDecoder" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py class">
<dt id="recode.ChunkedEncoder">
<em class="property">class </em><code class="sig-prename descclassname">recode.</code><code class="sig-name descname">ChunkedEncoder</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">*</span><span class="n">args</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwds</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/recode.html#ChunkedEncoder"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#recode.ChunkedEncoder" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py class">
<dt id="recode.IterativeDecoder">
<em class="property">class </em><code class="sig-prename descclassname">recode.</code><code class="sig-name descname">IterativeDecoder</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">*</span><span class="n">args</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwds</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/recode.html#IterativeDecoder"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#recode.IterativeDecoder" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py class">
<dt id="recode.MetaDecoder">
<em class="property">class </em><code class="sig-prename descclassname">recode.</code><code class="sig-name descname">MetaDecoder</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">*</span><span class="n">args</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwds</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/recode.html#MetaDecoder"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#recode.MetaDecoder" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py class">
<dt id="recode.MetaEncoder">
<em class="property">class </em><code class="sig-prename descclassname">recode.</code><code class="sig-name descname">MetaEncoder</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">*</span><span class="n">args</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwds</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/recode.html#MetaEncoder"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#recode.MetaEncoder" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py class">
<dt id="recode.StructCodecSpecs">
<em class="property">class </em><code class="sig-prename descclassname">recode.</code><code class="sig-name descname">StructCodecSpecs</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">chk_format</span><span class="p">:</span> <span class="n">str</span></em>, <em class="sig-param"><span class="n">n_channels</span><span class="p">:</span> <span class="n">int</span> <span class="o">=</span> <span class="default_value">None</span></em>, <em class="sig-param"><span class="n">chk_size_bytes</span><span class="p">:</span> <span class="n">int</span> <span class="o">=</span> <span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/recode.html#StructCodecSpecs"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#recode.StructCodecSpecs" title="Permalink to this definition">¶</a></dt>
<dd><p>Enable the definition of codec specs based on format characters of the
python struct module
(<a class="reference external" href="https://docs.python.org/3/library/struct.html#format-characters">https://docs.python.org/3/library/struct.html#format-characters</a>)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>chk_format</strong> – The format of a chunk, as specified by the struct module
See <a class="reference external" href="https://docs.python.org/3/library/struct.html#format-characters">https://docs.python.org/3/library/struct.html#format-characters</a></p></li>
<li><p><strong>n_channels</strong> – Only n_channels = 1 serves a purpose; to indicate that</p></li>
</ul>
</dd>
</dl>
<p>To utilise recode, first define your codec specs. If your frame is only one channel (ex. a list) then your format
string will include two characters, a byte character (&#64;, =, &lt;, &gt;, !) and a format character. The format character
should match the data type of the samples in the frame so they are properly encoded/decoded. This can be seen in the
following example.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">specs</span> <span class="o">=</span> <span class="n">StructCodecSpecs</span><span class="p">(</span><span class="n">chk_format</span><span class="o">=</span><span class="s1">&#39;h&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">specs</span><span class="p">)</span>
<span class="go">StructCodecSpecs(chk_format=&#39;h&#39;, n_channels=1, chk_size_bytes=2)</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">encoder</span> <span class="o">=</span> <span class="n">ChunkedEncoder</span><span class="p">(</span><span class="n">frame_to_chk</span><span class="o">=</span><span class="n">specs</span><span class="o">.</span><span class="n">frame_to_chk</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">decoder</span> <span class="o">=</span> <span class="n">ChunkedDecoder</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">chk_size_bytes</span><span class="o">=</span><span class="n">specs</span><span class="o">.</span><span class="n">chk_size_bytes</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">chk_to_frame</span><span class="o">=</span><span class="n">specs</span><span class="o">.</span><span class="n">chk_to_frame</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">n_channels</span><span class="o">=</span><span class="n">specs</span><span class="o">.</span><span class="n">n_channels</span>
<span class="gp">... </span><span class="p">)</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">frames</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">encoder</span><span class="p">(</span><span class="n">frames</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">b</span> <span class="o">==</span> <span class="sa">b</span><span class="s1">&#39;</span><span class="se">\x01\x00\x02\x00\x03\x00</span><span class="s1">&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">decoded_frames</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">decoder</span><span class="p">(</span><span class="n">b</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">decoded_frames</span> <span class="o">==</span> <span class="n">frames</span>
</pre></div>
</div>
<p>If your data has more than one channel, then there are two options. If all of the samples are of the same data type,
say integer, then your format string needs only one format character and then you can specify the number of channels
in your data with the n_channels argument. This can be seen in the following example.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">specs</span> <span class="o">=</span> <span class="n">StructCodecSpecs</span><span class="p">(</span><span class="n">chk_format</span><span class="o">=</span><span class="s1">&#39;@h&#39;</span><span class="p">,</span> <span class="n">n_channels</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">specs</span><span class="p">)</span>
<span class="go">StructCodecSpecs(chk_format=&#39;@hh&#39;, n_channels=2, chk_size_bytes=4)</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">encoder</span> <span class="o">=</span> <span class="n">ChunkedEncoder</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">frame_to_chk</span><span class="o">=</span><span class="n">specs</span><span class="o">.</span><span class="n">frame_to_chk</span>
<span class="gp">... </span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">decoder</span> <span class="o">=</span> <span class="n">ChunkedDecoder</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">chk_size_bytes</span><span class="o">=</span><span class="n">specs</span><span class="o">.</span><span class="n">chk_size_bytes</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">chk_to_frame</span><span class="o">=</span><span class="n">specs</span><span class="o">.</span><span class="n">chk_to_frame</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">n_channels</span><span class="o">=</span><span class="n">specs</span><span class="o">.</span><span class="n">n_channels</span>
<span class="gp">... </span><span class="p">)</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">frames</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">)]</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">encoder</span><span class="p">(</span><span class="n">frames</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">b</span> <span class="o">==</span> <span class="sa">b</span><span class="s1">&#39;</span><span class="se">\x01\x00\x02\x00\x03\x00\x04\x00\x05\x00\x06\x00</span><span class="s1">&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">decoded_frames</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">decoder</span><span class="p">(</span><span class="n">b</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">decoded_frames</span> <span class="o">==</span> <span class="n">frames</span>
</pre></div>
</div>
<p>On the other hand, if each channel has a different data type, say (int, float, int), then your format string needs
a format character for each of your channels. This can be seen in the following example, which also shows the use
of a different byte character (=).</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">specs</span> <span class="o">=</span> <span class="n">StructCodecSpecs</span><span class="p">(</span><span class="n">chk_format</span> <span class="o">=</span> <span class="s1">&#39;=hdh&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">specs</span><span class="p">)</span>
<span class="go">StructCodecSpecs(chk_format=&#39;=hdh&#39;, n_channels=3, chk_size_bytes=12)</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">encoder</span> <span class="o">=</span> <span class="n">ChunkedEncoder</span><span class="p">(</span><span class="n">frame_to_chk</span> <span class="o">=</span> <span class="n">specs</span><span class="o">.</span><span class="n">frame_to_chk</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">decoder</span> <span class="o">=</span> <span class="n">ChunkedDecoder</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">chk_size_bytes</span> <span class="o">=</span> <span class="n">specs</span><span class="o">.</span><span class="n">chk_size_bytes</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">chk_to_frame</span> <span class="o">=</span> <span class="n">specs</span><span class="o">.</span><span class="n">chk_to_frame</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">n_channels</span> <span class="o">=</span> <span class="n">specs</span><span class="o">.</span><span class="n">n_channels</span>
<span class="gp">... </span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">frames</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">1</span><span class="p">,</span> <span class="mf">2.45</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mf">4.321</span><span class="p">,</span> <span class="mi">3</span><span class="p">)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">encoder</span><span class="p">(</span><span class="n">frames</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">b</span> <span class="o">==</span> <span class="sa">b</span><span class="s1">&#39;</span><span class="se">\x01\x00\x9a\x99\x99\x99\x99\x99\x03</span><span class="s1">@</span><span class="se">\x01\x00\x03\x00</span><span class="s1">b</span><span class="se">\x10</span><span class="s1">X9</span><span class="se">\xb4</span><span class="s1">H</span><span class="se">\x11</span><span class="s1">@</span><span class="se">\x03\x00</span><span class="s1">&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">decoded_frames</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">decoder</span><span class="p">(</span><span class="n">b</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">decoded_frames</span> <span class="o">==</span> <span class="n">frames</span>
</pre></div>
</div>
<p>Along with a ChunkedDecoder, you can also use an IterativeDecoder which implements the struct.iter_unpack function.
IterativeDecoder only requires one argument, a chk_to_frame_iter function, and returns an iterator of each chunk.
An example of an IterativeDecorator can be seen below.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">specs</span> <span class="o">=</span> <span class="n">StructCodecSpecs</span><span class="p">(</span><span class="n">chk_format</span> <span class="o">=</span> <span class="s1">&#39;hdhd&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">specs</span><span class="p">)</span>
<span class="go">StructCodecSpecs(chk_format=&#39;hdhd&#39;, n_channels=4, chk_size_bytes=32)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">encoder</span> <span class="o">=</span> <span class="n">ChunkedEncoder</span><span class="p">(</span><span class="n">frame_to_chk</span> <span class="o">=</span> <span class="n">specs</span><span class="o">.</span><span class="n">frame_to_chk</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">decoder</span> <span class="o">=</span> <span class="n">IterativeDecoder</span><span class="p">(</span><span class="n">chk_to_frame</span> <span class="o">=</span> <span class="n">specs</span><span class="o">.</span><span class="n">chk_to_frame_iter</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">frames</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">1</span><span class="p">,</span><span class="mf">1.1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mf">1.1</span><span class="p">),(</span><span class="mi">2</span><span class="p">,</span><span class="mf">2.2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mf">2.2</span><span class="p">),(</span><span class="mi">3</span><span class="p">,</span><span class="mf">3.3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mf">3.3</span><span class="p">)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">encoder</span><span class="p">(</span><span class="n">frames</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">iter_frames</span> <span class="o">=</span> <span class="n">decoder</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="nb">next</span><span class="p">(</span><span class="n">iter_frames</span><span class="p">)</span> <span class="o">==</span> <span class="n">frames</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">next</span><span class="p">(</span><span class="n">iter_frames</span><span class="p">)</span>
<span class="go">(2, 2.2, 2, 2.2)</span>
</pre></div>
</div>
<p>Along with using recode for the kinds of data we have looked at so far, it can also be applied to DataFrames when
they have been converted to a list of dicts using MetaEncoder and MetaDecoder. An example of this can be seen below.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="p">[{</span><span class="s1">&#39;foo&#39;</span><span class="p">:</span> <span class="mf">1.1</span><span class="p">,</span> <span class="s1">&#39;bar&#39;</span><span class="p">:</span> <span class="mf">2.2</span><span class="p">},</span> <span class="p">{</span><span class="s1">&#39;foo&#39;</span><span class="p">:</span> <span class="mf">513.23</span><span class="p">,</span> <span class="s1">&#39;bar&#39;</span><span class="p">:</span> <span class="mf">456.1</span><span class="p">},</span> <span class="p">{</span><span class="s1">&#39;foo&#39;</span><span class="p">:</span> <span class="mf">32.0</span><span class="p">,</span> <span class="s1">&#39;bar&#39;</span><span class="p">:</span> <span class="mf">6.7</span><span class="p">}]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">specs</span> <span class="o">=</span> <span class="n">StructCodecSpecs</span><span class="p">(</span><span class="n">chk_format</span><span class="o">=</span><span class="s1">&#39;d&#39;</span><span class="p">,</span> <span class="n">n_channels</span> <span class="o">=</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">specs</span><span class="p">)</span>
<span class="go">StructCodecSpecs(chk_format=&#39;dd&#39;, n_channels=2, chk_size_bytes=16)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">encoder</span> <span class="o">=</span> <span class="n">MetaEncoder</span><span class="p">(</span><span class="n">frame_to_chk</span> <span class="o">=</span> <span class="n">specs</span><span class="o">.</span><span class="n">frame_to_chk</span><span class="p">,</span> <span class="n">frame_to_meta</span> <span class="o">=</span> <span class="n">frames_to_meta</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">decoder</span> <span class="o">=</span> <span class="n">MetaDecoder</span><span class="p">(</span><span class="n">chk_to_frame</span> <span class="o">=</span> <span class="n">specs</span><span class="o">.</span><span class="n">chk_to_frame</span><span class="p">,</span> <span class="n">n_channels</span> <span class="o">=</span> <span class="n">specs</span><span class="o">.</span><span class="n">n_channels</span><span class="p">,</span>
<span class="gp">... </span>                     <span class="n">chk_size_bytes</span> <span class="o">=</span> <span class="n">specs</span><span class="o">.</span><span class="n">chk_size_bytes</span><span class="p">,</span> <span class="n">meta_to_frame</span> <span class="o">=</span> <span class="n">meta_to_frames</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">encoder</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">decoder</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="o">==</span> <span class="n">data</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="recode.frames_to_meta">
<code class="sig-prename descclassname">recode.</code><code class="sig-name descname">frames_to_meta</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">frames</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/recode.html#frames_to_meta"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#recode.frames_to_meta" title="Permalink to this definition">¶</a></dt>
<dd><div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">rows</span> <span class="o">=</span> <span class="p">[{</span><span class="s1">&#39;customer&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">},</span> <span class="p">{</span><span class="s1">&#39;customer&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">},</span> <span class="p">{</span><span class="s1">&#39;customer&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">}]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">frames_to_meta</span><span class="p">(</span><span class="n">rows</span><span class="p">)</span> <span class="o">==</span> <span class="sa">b</span><span class="s1">&#39;</span><span class="se">\x08\x00</span><span class="s1">customer&#39;</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="recode.meta_to_frames">
<code class="sig-prename descclassname">recode.</code><code class="sig-name descname">meta_to_frames</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">meta</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/recode.html#meta_to_frames"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#recode.meta_to_frames" title="Permalink to this definition">¶</a></dt>
<dd><div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">meta</span> <span class="o">=</span> <span class="sa">b</span><span class="s1">&#39;</span><span class="se">\x1c\x00</span><span class="s1">customer.apple.banana.tomato</span><span class="se">\x01\x00\x01\x00\x02\x00\x03\x00\x02\x00\</span>
<span class="gp">... </span><span class="s1">x03</span><span class="se">\x00\x02\x00\x05\x00\x01\x00\x03\x00\x04\x00\t\x00</span><span class="s1">&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">meta_to_frames</span><span class="p">(</span><span class="n">meta</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="p">[</span><span class="s1">&#39;customer&#39;</span><span class="p">,</span> <span class="s1">&#39;apple&#39;</span><span class="p">,</span> <span class="s1">&#39;banana&#39;</span><span class="p">,</span> <span class="s1">&#39;tomato&#39;</span><span class="p">]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="recode.specs_from_frames">
<code class="sig-prename descclassname">recode.</code><code class="sig-name descname">specs_from_frames</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">frames</span><span class="p">:</span> <span class="n">Iterable<span class="p">[</span>Union<span class="p">[</span>Any<span class="p">, </span>Sequence<span class="p">[</span>Any<span class="p">]</span><span class="p">]</span><span class="p">]</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/recode.html#specs_from_frames"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#recode.specs_from_frames" title="Permalink to this definition">¶</a></dt>
<dd><p>Implicitly defines the codec specs based on the frames to encode/decode.
specs_from_frames returns a tuple of an iterator of frames and the defined StructCodecSpecs. If frames is an
iterable, then the iterator can be ignored like the following example.
&gt;&gt;&gt; frames = [1,2,3]
&gt;&gt;&gt; _, specs = specs_from_frames(frames)
&gt;&gt;&gt; print(specs)
StructCodecSpecs(chk_format=’h’, n_channels=1, chk_size_bytes=2)
&gt;&gt;&gt; encoder = ChunkedEncoder(frame_to_chk = specs.frame_to_chk)
&gt;&gt;&gt; decoder = ChunkedDecoder(
…     chk_to_frame = specs.chk_to_frame,
…     n_channels = specs.n_channels,
…     chk_size_bytes = specs.chk_size_bytes
… )
&gt;&gt;&gt; b = encoder(frames)
&gt;&gt;&gt; assert b == b’x01x00x02x00x03x00’
&gt;&gt;&gt; decoded_frames = list(decoder(b))
&gt;&gt;&gt; assert decoded_frames == frames</p>
<p>If frames is an iterator, then we can still use specs_from_frames as long as we redefine frames from the output like
in the following example.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">frames</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">([[</span><span class="mf">1.1</span><span class="p">,</span><span class="mf">2.2</span><span class="p">],[</span><span class="mf">3.3</span><span class="p">,</span><span class="mf">4.4</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">frames</span><span class="p">,</span> <span class="n">specs</span> <span class="o">=</span> <span class="n">specs_from_frames</span><span class="p">(</span><span class="n">frames</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">specs</span><span class="p">)</span>
<span class="go">StructCodecSpecs(chk_format=&#39;dd&#39;, n_channels=2, chk_size_bytes=16)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">encoder</span> <span class="o">=</span> <span class="n">ChunkedEncoder</span><span class="p">(</span><span class="n">frame_to_chk</span> <span class="o">=</span> <span class="n">specs</span><span class="o">.</span><span class="n">frame_to_chk</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">decoder</span> <span class="o">=</span> <span class="n">ChunkedDecoder</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">chk_to_frame</span> <span class="o">=</span> <span class="n">specs</span><span class="o">.</span><span class="n">chk_to_frame</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">n_channels</span> <span class="o">=</span> <span class="n">specs</span><span class="o">.</span><span class="n">n_channels</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">chk_size_bytes</span> <span class="o">=</span> <span class="n">specs</span><span class="o">.</span><span class="n">chk_size_bytes</span>
<span class="gp">... </span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">encoder</span><span class="p">(</span><span class="n">frames</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">decoded_frames</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">decoder</span><span class="p">(</span><span class="n">b</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">decoded_frames</span> <span class="o">==</span> <span class="p">[(</span><span class="mf">1.1</span><span class="p">,</span><span class="mf">2.2</span><span class="p">),(</span><span class="mf">3.3</span><span class="p">,</span><span class="mf">4.4</span><span class="p">)]</span>
</pre></div>
</div>
</dd></dl>

</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../index.html">recode</a></h1>








<h3>Navigation</h3>
<p><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="current reference internal" href="#">recode</a></li>
<li class="toctree-l1"><a class="reference internal" href="recode/util.html">recode.util</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../index.html">Documentation overview</a><ul>
      <li>Previous: <a href="../index.html" title="previous chapter">Welcome to recode’s documentation!</a></li>
      <li>Next: <a href="recode/util.html" title="next chapter">recode.util</a></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;NO COPYRIGHT.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 3.3.1</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../_sources/module_docs/recode.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>